.template 0
#   zproto_codec_python.gsl
#
#   Generates a codec for a protocol specification
#
include "zproto_lib.gsl"
include "zproto_lib_java.gsl"
include "zproto_bnf.gsl"
resolve_includes ()
expand_headers ()
generate_bnf ()
set_defaults ()
.endtemplate
.global.ClassName = java_class_name($(class.name))
.global.namespace ?= switches.namespace? "org.zproto"
.global.name_path ?= switches.name_path? "org/zproto"
.global.topdir ?= switches.topdir? "."
.directory.create ("$(topdir)/python/$(name_path)")
.output "$(topdir)/python/$(name_path)/$(ClassName).py"
/*  =========================================================================
    $(ClassName) - $(class.title:)

    ** WARNING *************************************************************
    THIS SOURCE FILE IS 100% GENERATED. If you edit this file, you will lose
    your changes at the next build cycle. This is great for temporary printf
    statements. DO NOT MAKE ANY CHANGES YOU WISH TO KEEP. The correct places
    for commits are:

    * The XML model used for this code generation: $(filename)
    * The code generation script that built this file: $(script)
    ************************************************************************
.   for class.license
    $(string.trim (license.):block                                         )
.   endfor
    =========================================================================
*/

/*  These are the $(ClassName) messages:
.for message

    $(NAME) - $(string.trim (.?''):left)
.   for field
.       if type = "number"
        $(name)             $(type) $(size)\
                                        $(field.?'':)
.       elsif type = "octets"
        $(name)             $(type) [$(size)]\
                                        $(field.?'':)
.       else
        $(name)             $(type)     $(field.?'':)
.       endif
.   endfor
.endfor
*/

package $(namespace);

#import java.util.*;
#import java.nio.ByteBuffer;

#import org.zeromq.ZFrame;
#import org.zeromq.ZMsg;
#import org.zeromq.ZMQ;
#import org.zeromq.ZMQ.Socket;
import zmq

class $(ClassName)(Object):

.for define
    $(CLASS.NAME)_$(DEFINE.NAME:C)  = $(value)
.endfor

.for message
    $(MESSAGE.NAME)       = $(id)
.endfor
.for class.field where type = "octets"
    $(FIELD.NAME)_SIZE    = $(size)
.endfor

    def __init__(self, id, *args, **kwargs):
        #  Structure of our class
        self.routingId = None               # Routing_id from ROUTER, if any
        self.id = id                        # $(ClassName) message ID
        self._needle = 0                    # Read/write pointer for serialization
        self.struct_data = b''

.for class.field
.   if type = "number"
.       if size = 1
.           field.ctype = "int"
.       elsif size = 2
.           field.ctype = "int"
.       elsif size = 4
.           field.ctype = "long"
.       elsif size = 8
.           field.ctype = "long"
.       else
.           echo "E: bad size $(size) for $(name)"
.       endif
    private $(ctype) $(name);
.   elsif type = "octets"
    private byte [] $(name) = new byte [$(size)];
.   elsif type = "number"
    private long $(name);
.   elsif type = "string" | type = "longstr"
    private String $(name);
.   elsif type = "strings"
    private List <String> $(name);
.   elsif type = "hash"
    private Map <String, String> $(name);
    private int $(name)Bytes;
.   elsif type = "frame" | type = "msg"
    private Z$(Type) $(name);
.   elsif type = "uuid"
    private UUID $(name);
.   elsif type = "chunk"
    private byte[] $(name);
.   endif
.endfor

    def __del__()
    {
        close();
    }

    @Override
    public void close()
    {
        //  Destroy frame fields
.for field where type = "frame"
        if ($(field.name) != null)
            $(field.name).destroy();
        $(field.name) = null;
.endfor
    }
    #  --------------------------------------------------------------------------
    #  Network data encoding macros


    #  Put a 1-byte number to the frame
    def _put_number1(self, nr):
        d = struct.pack('>b', nr)
        self.struct_data += d

    #  Get a 1-byte number to the frame
    #  then make it unsigned
    def _get_number1(self):
        num = struct.unpack_from('>b', self.struct_data, offset=self._needle)
        self._needle += struct.calcsize('>b')
        return num[0]

    #  Put a 2-byte number to the frame
    def _put_number2(self, nr):
        d = struct.pack('>H', nr)
        self.struct_data += d

    # Get a 2-byte number from the frame
    def _get_number2(self):
        num = struct.unpack_from('>H', self.struct_data, offset=self._needle)
        self._needle += struct.calcsize('>H')
        return num[0]

    #  Put a 4-byte number to the frame
    def _put_number4(self, nr):
        d = struct.pack('>I', nr)
        self.struct_data += d

    #  Get a 4-byte number to the frame
    def _get_number4(self):
        num = struct.unpack_from('>I', self.struct_data, offset=self._needle)
        self._needle += struct.calcsize('>I')
        return num[0]

    #  Put a 8-byte number to the frame
    def _put_number8(self, nr):
        d = struct.pack('>Q', nr)
        self.struct_data += d   

    #  Get a 8-byte number to the frame
    def _get_number8(self):
        num = struct.unpack_from('>Q', self.struct_data, offset=self._needle)
        self._needle += struct.calcsize('>Q')
        return num[0]

    //  Put a block to the frame
    private void putBlock (byte [] value, int size)
    {
        needle.put (value, 0, size);
    }

    private byte [] getBlock (int size)
    {
        byte [] value = new byte [size];
        needle.get (value);

        return value;
    }

    #  Put a string to the frame
    def _put_string(self, s):
        self._put_number1(len(s))
        d = struct.pack('%is' % len(s), s.encode('UTF-8'))
        self.struct_data += d

    #  Get a string from the frame
    def _get_string(self):
        s_len = self._get_number1()
        s = struct.unpack_from(str(s_len) + 's', self.struct_data, offset=self._needle)
        self._needle += struct.calcsize('s' * s_len)
        return s[0].decode('UTF-8')

    #  Put a long string to the frame
    def _put_long_string(self, s):
        self._put_number4(len(s))
        d = struct.pack('%is' % len(s), s.encode('UTF-8'))
        self.struct_data += d

    #  Get a string from the frame
    def _get_long_string(self):
        s_len = self._get_number4()
        s = struct.unpack_from(str(s_len) + 's', self.struct_data, offset=self._needle)
        self._needle += struct.calcsize('s' * s_len)
        return s[0].decode('UTF-8')

    #  --------------------------------------------------------------------------
    #  Receive and parse a $(ClassName) from the socket. Returns new object or
    #  null if error. Will block if there's no message waiting.
    def recv (insocket):
    {
        frames = insocket.recv_multipart()
        if insocket.type == zmq.ROUTER:
            self.routing_id = frames.pop(0)

        self.struct_data = frames.pop(0)
        logger.debug("recv data: {0}".format(self.struct_data))
        if not self.struct_data:
            logger.debug("Malformed msg")        
            return

        # reset needle
        self._needle = 0        
        self._ceiling = len(self.struct_data)

        signature = self._get_number2()
        if signature != (0xAAA0 | $(class.signature)): 
            logger.debug("Invalid signature {0}".format(signature))
            return

        
        self.id = self._get_number1()
        version = self._get_number1()

.for class.message where count (field)
        if self.id == $(CLASS.NAME).$(MESSAGE.NAME):
.   for field
.       if type = "number"
                self.$(name) = self._get_number$(size)()
.               if defined (field.value)
                if self.$(name) != $(field.value:)
                    #??? raise IllegalArgumentException()
                    logger.debug("Value {0} != {1}".format(self.$(name), $(field.value:)))
.           endif
.       elsif type = "octets"
                self.$(name) = self.getBlock ($(size));
.           if defined (field.value)
                if self.$(name) != $(field.value:) 
                    #??? raise IllegalArgumentException()
                    logger.debug("Value {0} != {1}".format(self.$(name), $(field.value:)))
.           endif
.       elsif type = "string"
                self.$(name) = self._get_string()
.           if defined (field.value)
                if self.$(name) != $(field.value:)
                    #??? raise IllegalArgumentException()
                    logger.debug("Value {0} != {1}".format(self.$(name), $(field.value:)))
.           endif
.       elsif type = "longstr"
                self.$(name) = self._get_long_string ();
.           if defined (field.value)
                if (!self.$(name).equals( "$(field.value:)"))
                    throw new IllegalArgumentException ();
.           endif
.       elsif type = "strings"
                list_size = self._get_number4()
                self.$(name) = []
                for x in range(list_size):
                    self.$(name).append(self._get_long_string());
.       elsif type = "hash"
                hash_size = self.get_number4()
                self.$(name) = {}
                for x in range(hash_size):
                    key = self._get_string()
                    val = self._get_long_string()
                    self.$(name).update({key: val})
.       elsif type = "chunk"
                #TODO
                self.$(name) = self.getBlock((int) self.getNumber4());
.       elsif type = "uuid"
                uuid_bytes = self._get_block(16)
                self.$(name) = uuid.UUID(bytes=uuid_bytes)
.       elsif type = "frame"
                # TODO  Get next frame, leave current untouched
                if (!input.hasReceiveMore ())
                    throw new IllegalArgumentException ();
                self.$(name) = ZFrame.recvFrame (input);
.       elsif type = "msg"
                #TODO self.$(name) = new ZMsg();
                if (input.hasReceiveMore ())
                    self.$(name).add(ZFrame.recvFrame (input));
.       endif
.    endfor
                break;
.endfor
        else:
            logger.debug("bad message ID")

    #  --------------------------------------------------------------------------
    #  Send the $(ClassName) to the socket, and destroy it

    def send(self, outsocket):
        if outsocket.socket_type == zmq.ROUTER:
            outsocket.send(self.routing_id, zmq.SNDMORE)
        # We could generalize to a ZMsg class? ZMsg msg = new ZMsg();

        self.struct_data = b''
        self._needle = 0

        # add signature
        self._put_number2(0xAAA0 | $(class.signature))
        self._put_number1(self.id)

.for class.message where count (field)
        if id == $(CLASS.NAME).$(MESSAGE.NAME):
.   for field
.       if type = "number"
            #  $(name) is a $(size)-byte integer
.           if defined (field.value)
            self._put_number$(size)($(value:))
.           else
            self._put_number$(size)(self.$(name))
.           endif
.       elsif type = "octets"
            #  $(name) is a block of $(size) bytes
            frameSize += $(size);
.       elsif type = "string"
.           if defined (field.value)
            self._put_string($(field.value:))
.           else
            if $(name) != None:
                self._put_string($(name))
            else
                self._put_number1(0)      #  Empty string
.           endif
.       elsif type = "longstr"
.           if defined (field.value)
            self._put_long_string($(field.value:))
.           else
            if $(name) != None:
                self._put_long_string($(name))
            else
                self._put_number4(0)      #  Empty string
.           endif
.       elsif type = "strings"
            if $(name) != None:
                self._put_number4(len($(name))
                for (String value : $(name)) {
                    self._put_long_string(value)
                }
            }
            else
                self._put_number4(0);      #  Empty string array
.       elsif type = "hash"
            if $(name) != None:
                self._put_number4(len($(name))
                for key, val in $(name).items():
                    self._put_string(key)
                    self._put_long_string(val)
                }
            }
            else
                self._put_number4(0)      #  Empty hash
.       elsif type = "chunk"
              # TODO
              if $(name) != None:
                  self._put_number4(len($(name)):
                  needle.put($(name), 0, $(name).length);
              } else {
                  self._put_number4(0)
              }
.       elsif type = "uuid"
              if $(name) != None:
                  #TODO
                  ByteBuffer bb = ByteBuffer.wrap(new byte[16]);
                  bb.putLong($(name).getMostSignificantBits());
                  bb.putLong($(name).getLeastSignificantBits());
                  needle.put(bb.array());
              } else {
                  self._put_chunk(b'0'*16)    #  Empty Chunk
              }
.       endif
.   endfor

.endfor
        }
        //  Now send the data frame
        .add(frame);
        outsocket.send(self.struct_data)


.for message
//  --------------------------------------------------------------------------
//  Send the $(message.NAME) to the socket in one step

    public static void send$(Name) (
        Socket output\
.for field where !defined (value)
,
.   if type = "number"
.       if size = 1
        int $(name)\
.       elsif size = 2
        int $(name)\
.       elsif size = 4
        long $(name)\
.       elsif size = 8
        long $(name)\
.       else
.           echo "E: bad size $(size) for $(name)"
.       endif
.   elsif type = "octets"
        byte [] $(name)\
.   elsif type = "string" | type = "longstr"
        String $(name)\
.   elsif type = "strings"
        List <String> $(name)\
.   elsif type = "hash"
        Map <String, String> $(name)\
.   elsif type = "frame" | type = "msg"
        Z$(Type) $(name)\
.   elsif type = "uuid"
        UUID $(name)\
.   elsif type = "chunk"
        byte[] $(name)\
.   else
        $(type) $(name)\
.   endif
.endfor
)
    {
	send$(Name) (
		    output,
		    null\
.              for field where !defined (value)
,
		    $(name)\
.              endfor
);
    }

//  --------------------------------------------------------------------------
//  Send the $(message.NAME) to a router socket in one step

    public static void send$(Name) (
        Socket output,
	ZFrame routingId\
.for field where !defined (value)
,
.   if type = "number"
.       if size = 1
        int $(name)\
.       elsif size = 2
        int $(name)\
.       elsif size = 4
        long $(name)\
.       elsif size = 8
        long $(name)\
.       else
.           echo "E: bad size $(size) for $(name)"
.       endif
.   elsif type = "octets"
        byte [] $(name)\
.   elsif type = "string" | type = "longstr"
        String $(name)\
.   elsif type = "strings"
        List <String> $(name)\
.   elsif type = "hash"
        Map <String, String> $(name)\
.   elsif type = "frame" | type = "msg"
        Z$(Type) $(name)\
.   elsif type = "uuid"
        UUID $(name)\
.   elsif type = "chunk"
        byte[] $(name)\
.   else
        $(type) $(name)\
.   endif
.endfor
)
    {
        $(ClassName) self = new $(ClassName) ($(ClassName).$(MESSAGE.NAME));
        if (routingId != null)
        {
	        self.setRoutingId (routingId);
        }
.for field where !defined (value)
.   if type = "number" | type = "octets" | type = "string" | type = "longstr" | type = "uuid" | type = "chunk"
        self.set$(Name) ($(name));
.   elsif type = "strings"
        self.set$(Name) (new ArrayList <String> ($(name)));
.   elsif type = "hash"
        self.set$(Name) (new HashMap <String, String> ($(name)));
.   elsif type = "frame" | type = "msg"
        self.set$(Name) ($(name).duplicate ());
.   endif
.endfor
        self.send (output);
    }

.endfor

    //  --------------------------------------------------------------------------
    //  Duplicate the $(ClassName) message

    public $(ClassName) dup ()
    {
        $(ClassName) copy = new $(ClassName) (this.id);
        if (this.routingId != null)
            copy.routingId = this.routingId.duplicate ();
        switch (this.id) {
.for class.message
        case $(MESSAGE.NAME):
.   for field
.       if type = "number"
            copy.$(name) = this.$(name);
.       elsif type = "octets"
            System.arraycopy (copy.$(name), 0, this.$(name), 0, $(size));
.       elsif type = "string" | type = "longstr" | type = "chunk"
            copy.$(name) = this.$(name);
.       elsif type = "strings"
            copy.$(name) = new ArrayList <String> (this.$(name));
.       elsif type = "hash"
            copy.$(name) = new HashMap <String, String> (this.$(name));
.       elsif type = "frame"
            copy.$(name) = this.$(name).duplicate ();
.       endif
.   endfor
        break;
.endfor
        }
        return copy;
    }

.for class.field where type = "hash"
    //  Dump $(name) key=value pair to stdout
    public static void $(name)Dump (Map.Entry <String, String> entry, $(ClassName) self)
    {
        System.out.printf ("        %s=%s\\n", entry.getKey (), entry.getValue ());
    }

.endfor

    //  --------------------------------------------------------------------------
    //  Print contents of message to stdout

    public void dump ()
    {
        switch (id) {
.for class.message
        case $(MESSAGE.NAME):
            System.out.println ("$(MESSAGE.NAME):");
.   for field
.       if type = "number"
.           if defined (field.value)
            System.out.printf ("    $(name)=$(field.value)\\n");
.           else
            System.out.printf ("    $(name)=%d\\n", (long)$(name));
.           endif
.       elsif type = "octets"
            System.out.printf ("    $(name)=");
            int $(name)Index;
            for ($(name)Index = 0; $(name)Index < $(size); $(name)Index++) {
                if ($(name)Index != 0 && ($(name)Index % 4 == 0))
                    System.out.printf ("-");
                System.out.printf ("%02X", $(name) [$(name)Index]);
            }
            System.out.println();
.       elsif type = "string" | type = "longstr"
.           if defined (field.value)
            System.out.printf ("    $(name)=$(field.value)\\n");
.           else
            if ($(name) != null)
                System.out.printf ("    $(name)='%s'\\n", $(name));
            else
                System.out.printf ("    $(name)=\\n");
.           endif
.       elsif type = "strings"
            System.out.printf ("    $(name)={");
            if ($(name) != null) {
                for (String value : $(name)) {
                    System.out.printf (" '%s'", value);
                }
            }
            System.out.printf (" }\\n");
.       elsif type = "hash"
            System.out.printf ("    $(name)={\\n");
            if ($(name) != null) {
                for (Map.Entry <String, String> entry : $(name).entrySet ())
                    $(name)Dump (entry, this);
            }
            System.out.printf ("    }\\n");
.       elsif type = "frame"
            System.out.printf ("    $(name)={\\n");
            if ($(name) != null) {
                int size = $(name).size ();
                byte [] data = $(name).getData ();
                System.out.printf ("        size=%d\\n", $(name).size ());
                if (size > 32)
                    size = 32;
                int $(name)Index;
                for ($(name)Index = 0; $(name)Index < size; $(name)Index++) {
                    if ($(name)Index != 0 && ($(name)Index % 4 == 0))
                        System.out.printf ("-");
                    System.out.printf ("%02X", data [$(name)Index]);
                }
            }
            System.out.printf ("    }\\n");
.       endif
.   endfor
            break;

.endfor
        }
    }


    //  --------------------------------------------------------------------------
    //  Get/set the message routing id

    public ZFrame routingId ()
    {
        return routingId;
    }

    public void setRoutingId (ZFrame routingId)
    {
        if (this.routingId != null)
            this.routingId.destroy ();
        this.routingId = routingId.duplicate ();
    }


    //  --------------------------------------------------------------------------
    //  Get/set the $(class.name) id

    public int id ()
    {
        return id;
    }

    public void setId (int id)
    {
        this.id = id;
    }

.for class.field where !defined (value)
.   if type = "number"
    //  --------------------------------------------------------------------------
    //  Get/set the $(name) field

    public $(ctype) $(name) ()
    {
        return $(name);
    }

    public void set$(Name) ($(ctype) $(name))
    {
        this.$(name) = $(name);
    }

.   elsif type = "octets"
    //  --------------------------------------------------------------------------
    //  Get/set the $(name) field

    public byte [] $(name) ()
    {
        return $(name);
    }

    public void set$(Name) (byte [] $(name))
    {
        System.arraycopy ($(name), 0, this.$(name), 0, $(size));
    }

.   elsif type = "string" | type = "longstr"
    //  --------------------------------------------------------------------------
    //  Get/set the $(name) field

    public String $(name) ()
    {
        return $(name);
    }

    public void set$(Name) (String format, Object ... args)
    {
        //  Format into newly allocated string
        $(name) = String.format (format, args);
    }

.   elsif type = "strings"
    //  --------------------------------------------------------------------------
    //  Iterate through the $(name) field, and append a $(name) value

    public List <String> $(name) ()
    {
        return $(name);
    }

    public void append$(Name) (String format, Object ... args)
    {
        //  Format into newly allocated string

        String string = String.format (format, args);
        //  Attach string to list
        if ($(name) == null)
            $(name) = new ArrayList <String> ();
        $(name).add (string);
    }

    public void set$(Name) (List <String> value)
    {
        $(name) = new ArrayList (value);
    }

.   elsif type = "hash"
    //  --------------------------------------------------------------------------
    //  Get/set a value in the $(name) hash

    public Map <String, String> $(name) ()
    {
        return $(name);
    }

    public String $(name)String (String key, String defaultValue)
    {
        String value = null;
        if ($(name) != null)
            value = $(name).get (key);
        if (value == null)
            value = defaultValue;

        return value;
    }

    public long $(name)Number (String key, long defaultValue)
    {
        long value = defaultValue;
        String string = null;
        if ($(name) != null)
            string = $(name).get (key);
        if (string != null)
            value = Long.valueOf (string);

        return value;
    }

    public void insert$(Name) (String key, String format, Object ... args)
    {
        //  Format string into buffer
        String string = String.format (format, args);

        //  Store string in hash table
        if ($(name) == null)
            $(name) = new HashMap <String, String> ();
        $(name).put (key, string);
        $(name)Bytes += key.length () + 1 + string.length ();
    }

    public void set$(Name) (Map <String, String> value)
    {
        if (value != null)
            $(name) = new HashMap <String, String> (value);
        else
            $(name) = value;
    }

.   elsif type = "frame" | type = "msg"
    //  --------------------------------------------------------------------------
    //  Get/set the $(name) field

    public Z$(Type) $(name) ()
    {
        return $(name);
    }

    //  Takes ownership of supplied frame
    public void set$(Name) (Z$(Type) frame)
    {
        if ($(name) != null)
            $(name).destroy ();
        $(name) = frame;
    }
.   elsif type = "uuid"
    //  --------------------------------------------------------------------------
    //  Get/set the $(name) field

    public UUID $(name) ()
    {
        return $(name);
    }

    public void set$(Name) (UUID $(name))
    {
        this.$(name) = $(name);
    }
.   elsif type = "chunk"
    //  --------------------------------------------------------------------------
    //  Get/set the $(name) field

    public byte[] $(name) ()
    {
        return $(name);
    }

    //  Takes ownership of supplied frame
    public void set$(Name) (byte[] $(name))
    {
        this.$(name) = $(name);
    }
.   endif
.endfor
}
.directory.create ("$(topdir)/test/java/$(name_path)")
.output "$(topdir)/test/java/$(name_path)/Test$(ClassName).java"
package $(namespace);

import static org.junit.Assert.*;
import org.junit.Test;
import org.zeromq.ZMQ;
import org.zeromq.ZMQ.Socket;
import org.zeromq.ZFrame;
import org.zeromq.ZContext;

public class Test$(ClassName)
{
    @Test
    public void test$(ClassName) ()
    {
        System.out.printf (" * $(class.name): ");

        //  Simple create/destroy test
        $(ClassName) self = new $(ClassName) (0);
        assert (self != null);
        self.destroy ();

        //  Create pair of sockets we can send through
        ZContext ctx = new ZContext ();
        assert (ctx != null);

        Socket output = ctx.createSocket (ZMQ.DEALER);
        assert (output != null);
        output.bind ("inproc://selftest");
        Socket input = ctx.createSocket (ZMQ.ROUTER);
        assert (input != null);
        input.connect ("inproc://selftest");

        //  Encode/send/decode and verify each message type
.for class.message

        self = new $(ClassName) ($(ClassName).$(MESSAGE.NAME));
.   for field where !defined (value)
.       if type = "number"
        self.set$(Name) ((byte) 123);
.       elsif type = "octets"
        byte [] $(name)Data = new byte [$(ClassName).$(FIELD.NAME)_SIZE];
        for (int i=0; i < $(ClassName).$(FIELD.NAME)_SIZE; i++)
            $(name)Data [i] = 123;
        self.set$(Name) ($(name)Data);
.       elsif type = "string" | type = "longstr"
        self.set$(Name) ("Life is short but Now lasts for ever");
.       elsif type = "strings"
        self.append$(Name) ("Name: %s", "Brutus");
        self.append$(Name) ("Age: %d", 43);
.       elsif type = "hash"
        self.insert$(Name) ("Name", "Brutus");
        self.insert$(Name) ("Age", "%d", 43);
.       elsif type = "chunk"
        self.set$(Name) ("Captcha Diem".getBytes());
.       elsif type = "frame"
        self.set$(Name) (new ZFrame ("Captcha Diem"));
.       endif
.   endfor
        self.send (output);

        self = $(ClassName).recv (input);
        assert (self != null);
.   for field where !defined (value)
.       if type = "number"
        assertEquals (self.$(name) (), 123);
.       elsif type = "octets"
        assertEquals (self.$(name) () [0], 123);
        assertEquals (self.$(name) () [$(ClassName).$(FIELD.NAME)_SIZE - 1], 123);
.       elsif type = "string" | type = "longstr"
        assertEquals (self.$(name) (), "Life is short but Now lasts for ever");
.       elsif type = "strings"
        assertEquals (self.$(name) ().size (), 2);
        assertEquals (self.$(name) ().get (0), "Name: Brutus");
        assertEquals (self.$(name) ().get (1), "Age: 43");
.       elsif type = "hash"
        assertEquals (self.$(name) ().size (), 2);
        assertEquals (self.$(name)String ("Name", "?"), "Brutus");
        assertEquals (self.$(name)Number ("Age", 0), 43);
.       elsif type = "chunk"
        assertTrue (java.util.Arrays.equals("Captcha Diem".getBytes(), self.$(name) ()));
.       elsif type = "frame"
        assertTrue (self.$(name) ().streq ("Captcha Diem"));
.       endif
.   endfor
        self.destroy ();
.endfor

        ctx.destroy ();
        System.out.printf ("OK\\n");
    }
}
