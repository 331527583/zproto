.template 0
#   zproto_codec_python.gsl
#
#   Generates a codec for a protocol specification
#
include "zproto_lib.gsl"
include "zproto_lib_java.gsl"
include "zproto_bnf.gsl"
resolve_includes ()
expand_headers ()
generate_bnf ()
set_defaults ()
.endtemplate
.global.ClassName = java_class_name($(class.name))
.global.namespace ?= switches.namespace? "zproto"
.global.name_path ?= switches.name_path? "zproto"
.global.topdir ?= switches.topdir? "."
.directory.create ("$(topdir)/python/$(name_path)")
.output "$(topdir)/python/$(name_path)/$(ClassName).py"
#  =========================================================================
#  $(ClassName) - $(class.title:)
#
#  ** WARNING *************************************************************
#  THIS SOURCE FILE IS 100% GENERATED. If you edit this file, you will lose
#  your changes at the next build cycle. This is great for temporary printf
#  statements. DO NOT MAKE ANY CHANGES YOU WISH TO KEEP. The correct places
#  for commits are:

#  * The XML model used for this code generation: $(filename)
#  * The code generation script that built this file: $(script)
#  ************************************************************************
"""
.   for class.license
    $(string.trim (license.):block                                         )
.   endfor
    =========================================================================
"""

"""  These are the $(ClassName) messages:
.for message

    $(NAME) - $(string.trim (.?''):left)
.   for field
.       if type = "number"
        $(name)             $(type) $(size)\
                                        $(field.?'':)
.       elsif type = "octets"
        $(name)             $(type) [$(size)]\
                                        $(field.?'':)
.       else
        $(name)             $(type)     $(field.?'':)
.       endif
.   endfor
.endfor
"""

package $(namespace);

import struct
import uuid
import zmq
import logging

class $(ClassName)(Object):

.for define
    $(CLASS.NAME)_$(DEFINE.NAME:C)  = $(value)
.endfor

.for message
    $(MESSAGE.NAME)       = $(id)
.endfor
.for class.field where type = "octets"
    $(FIELD.NAME)_SIZE    = $(size)
.endfor

    def __init__(self, id, *args, **kwargs):
        #  Structure of our class
        self.routingId = None               # Routing_id from ROUTER, if any
        self.id = id                        # $(ClassName) message ID
        self._needle = 0                    # Read/write pointer for serialization
        self.struct_data = b''

.for class.field
.   if type = "number"
.       if size = 1
.           field.ctype = "int"
.       elsif size = 2
.           field.ctype = "int"
.       elsif size = 4
.           field.ctype = "long"
.       elsif size = 8
.           field.ctype = "long"
.       else
.           echo "E: bad size $(size) for $(name)"
.       endif
    private $(ctype) $(name);
.   elsif type = "octets"
    private byte [] $(name) = new byte [$(size)];
.   elsif type = "number"
    private long $(name);
.   elsif type = "string" | type = "longstr"
    private String $(name);
.   elsif type = "strings"
    private List <String> $(name);
.   elsif type = "hash"
    private Map <String, String> $(name);
    private int $(name)Bytes;
.   elsif type = "frame" | type = "msg"
    private Z$(Type) $(name);
.   elsif type = "uuid"
    private UUID $(name);
.   elsif type = "chunk"
    private byte[] $(name);
.   endif
.endfor

    #  --------------------------------------------------------------------------
    #  Network data encoding macros

    #  Put a 1-byte number to the frame
    def _put_number1(self, nr):
        d = struct.pack('>b', nr)
        self.struct_data += d

    #  Get a 1-byte number to the frame
    #  then make it unsigned
    def _get_number1(self):
        num = struct.unpack_from('>b', self.struct_data, offset=self._needle)
        self._needle += struct.calcsize('>b')
        return num[0]

    #  Put a 2-byte number to the frame
    def _put_number2(self, nr):
        d = struct.pack('>H', nr)
        self.struct_data += d

    # Get a 2-byte number from the frame
    def _get_number2(self):
        num = struct.unpack_from('>H', self.struct_data, offset=self._needle)
        self._needle += struct.calcsize('>H')
        return num[0]

    #  Put a 4-byte number to the frame
    def _put_number4(self, nr):
        d = struct.pack('>I', nr)
        self.struct_data += d

    #  Get a 4-byte number to the frame
    def _get_number4(self):
        num = struct.unpack_from('>I', self.struct_data, offset=self._needle)
        self._needle += struct.calcsize('>I')
        return num[0]

    #  Put a 8-byte number to the frame
    def _put_number8(self, nr):
        d = struct.pack('>Q', nr)
        self.struct_data += d   

    #  Get a 8-byte number to the frame
    def _get_number8(self):
        num = struct.unpack_from('>Q', self.struct_data, offset=self._needle)
        self._needle += struct.calcsize('>Q')
        return num[0]

    //  Put a block to the frame
    private void putBlock (byte [] value, int size)
    {
        needle.put (value, 0, size);
    }

    private byte [] getBlock (int size)
    {
        byte [] value = new byte [size];
        needle.get (value);

        return value;
    }

    #  Put a string to the frame
    def _put_string(self, s):
        self._put_number1(len(s))
        d = struct.pack('%is' % len(s), s.encode('UTF-8'))
        self.struct_data += d

    #  Get a string from the frame
    def _get_string(self):
        s_len = self._get_number1()
        s = struct.unpack_from(str(s_len) + 's', self.struct_data, offset=self._needle)
        self._needle += struct.calcsize('s' * s_len)
        return s[0].decode('UTF-8')

    #  Put a long string to the frame
    def _put_long_string(self, s):
        self._put_number4(len(s))
        d = struct.pack('%is' % len(s), s.encode('UTF-8'))
        self.struct_data += d

    #  Get a string from the frame
    def _get_long_string(self):
        s_len = self._get_number4()
        s = struct.unpack_from(str(s_len) + 's', self.struct_data, offset=self._needle)
        self._needle += struct.calcsize('s' * s_len)
        return s[0].decode('UTF-8')

# Skipped recv from zmsg
# Skipped senf to zmsg

    #  --------------------------------------------------------------------------
    #  Receive a $(ClassName) from the socket. Returns new object or
    #  null if error. Will block if there's no message waiting.
    def recv (self, insocket):
    {
        frames = insocket.recv_multipart()
        if insocket.type == zmq.ROUTER:
            self.routing_id = frames.pop(0)

        self.struct_data = frames.pop(0)
        logger.debug("recv data: {0}".format(self.struct_data))
        if not self.struct_data:
            logger.debug("Malformed msg")        
            return

        # Get and check protocol signature
        self._needle = 0        
        self._ceiling = len(self.struct_data)

# TODO what is zdigest?
.if switches.digest ?= 1
    zdigest_t *digest = zdigest_new ();
.endif
        signature = self._get_number2()
        if signature != (0xAAA0 | $(class.signature)): 
            logger.debug("Invalid signature {0}".format(signature))
            return
   
        self.id = self._get_number1()
        version = self._get_number1()

.for class.message where count (field)
        if self.id == $(CLASS.NAME).$(MESSAGE.NAME):
.   for field
.       if type = "number"
                self.$(name) = self._get_number$(size)()
.               if defined (field.value)
                if self.$(name) != $(field.value:)
                    #??? raise IllegalArgumentException()
                    logger.debug("Value {0} != {1}".format(self.$(name), $(field.value:)))
.           endif
.       elsif type = "octets"
                self.$(name) = self.getBlock ($(size));
.           if defined (field.value)
                if self.$(name) != $(field.value:) 
                    #??? raise IllegalArgumentException()
                    logger.debug("Value {0} != {1}".format(self.$(name), $(field.value:)))
.           endif
.       elsif type = "string"
                self.$(name) = self._get_string()
.           if defined (field.value)
                if self.$(name) != $(field.value:)
                    #??? raise IllegalArgumentException()
                    logger.debug("Value {0} != {1}".format(self.$(name), $(field.value:)))
.           endif
.       elsif type = "longstr"
                self.$(name) = self._get_long_string ();
.           if defined (field.value)
                if (!self.$(name).equals( "$(field.value:)"))
                    throw new IllegalArgumentException ();
.           endif
.       elsif type = "strings"
                list_size = self._get_number4()
                self.$(name) = []
                for x in range(list_size):
                    self.$(name).append(self._get_long_string());
.       elsif type = "hash"
                hash_size = self.get_number4()
                self.$(name) = {}
                for x in range(hash_size):
                    key = self._get_string()
                    val = self._get_long_string()
                    self.$(name).update({key: val})
.       elsif type = "chunk"
                #TODO
                self.$(name) = self.getBlock((int) self.getNumber4());
.       elsif type = "uuid"
                uuid_bytes = self._get_block(16)
                self.$(name) = uuid.UUID(bytes=uuid_bytes)
.       elsif type = "frame"
                # TODO  Get next frame, leave current untouched
                if (!input.hasReceiveMore ())
                    throw new IllegalArgumentException ();
                self.$(name) = ZFrame.recvFrame (input);
.       elsif type = "msg"
                #TODO self.$(name) = new ZMsg();
                if (input.hasReceiveMore ())
                    self.$(name).add(ZFrame.recvFrame (input));
.       endif
.    endfor
                break;
.endfor
        else:
            logger.debug("bad message ID")

    #  --------------------------------------------------------------------------
    #  Send the $(ClassName) to the socket, and destroy it

    def send(self, outsocket):
        if outsocket.socket_type == zmq.ROUTER:
            outsocket.send(self.routing_id, zmq.SNDMORE)
        # We could generalize to a ZMsg class? ZMsg msg = new ZMsg();

        self.struct_data = b''
        self._needle = 0

        # add signature
        self._put_number2(0xAAA0 | $(class.signature))
        self._put_number1(self.id)

.for class.message where count (field)
        if id == $(CLASS.NAME).$(MESSAGE.NAME):
.   for field
.       if type = "number"
            #  $(name) is a $(size)-byte integer
.           if defined (field.value)
            self._put_number$(size)($(value:))
.           else
            self._put_number$(size)(self.$(name))
.           endif
.       elsif type = "octets"
            # TODO $(name) is a block of $(size) bytes
            frameSize += $(size);
.       elsif type = "string"
.           if defined (field.value)
            self._put_string($(field.value:))
.           else
            if $(name) != None:
                self._put_string($(name))
            else
                self._put_number1(0)      #  Empty string
.           endif
.       elsif type = "longstr"
.           if defined (field.value)
            self._put_long_string($(field.value:))
.           else
            if $(name) != None:
                self._put_long_string($(name))
            else
                self._put_number4(0)      #  Empty string
.           endif
.       elsif type = "strings"
            if $(name) != None:
                self._put_number4(len($(name))
                for (String value : $(name)) {
                    self._put_long_string(value)
                }
            }
            else
                self._put_number4(0);      #  Empty string array
.       elsif type = "hash"
            if $(name) != None:
                self._put_number4(len($(name))
                for key, val in $(name).items():
                    self._put_string(key)
                    self._put_long_string(val)
                }
            }
            else
                self._put_number4(0)      #  Empty hash
.       elsif type = "chunk"
              # TODO
              if $(name) != None:
                  self._put_number4(len($(name)):
                  needle.put($(name), 0, $(name).length);
              } else {
                  self._put_number4(0)
              }
.       elsif type = "uuid"
              if $(name) != None:
                  #TODO
                  self._put_bytes(self.uuid.bytes)
                  #ByteBuffer bb = ByteBuffer.wrap(new byte[16]);
                  #bb.putLong($(name).getMostSignificantBits());
                  #bb.putLong($(name).getLeastSignificantBits());
                  #needle.put(bb.array());
              } else {
                  self._put_chunk(b'0'*16)    #  Empty Chunk
              }
.       elsif type = "frame"
            # TODO frame
.       elsif type = "msg"
            # TODO msg
.       endif
.   endfor

.endfor

        #  Now send the data frame
        outsocket.send(self.struct_data)
.for class.message where count (field, type = "frame")
        #  Now send any frame fields, in order
        if (self->id == $(CLASS.NAME)_$(MESSAGE.NAME)) {
.   for field where type = "frame"
        #  If $(name) isn't set, send an empty frame
        if (self->$(field.name))
            zframe_send (&self->$(field.name), output, ZFRAME_REUSE + (--nbr_frames? ZFRAME_MORE: 0));
        else
            zmq_send (zsock_resolve (output), NULL, 0, (--nbr_frames? ZMQ_SNDMORE: 0));
.   endfor
.endfor
.if defined (class.msg)
    #  Now send the $(class.msg) if necessary
    if (have_$(class.msg)):
        if (self.$(class.msg)):
            frame = zmsg_first (self.$(class.msg))
            while (frame):
                zframe_send (&frame, output, ZFRAME_REUSE + (--nbr_frames? ZFRAME_MORE: 0))
                frame = zmsg_next (self->$(class.msg))
        else:
            zmq_send (zsock_resolve (output), NULL, 0, 0)
.endif


    #  --------------------------------------------------------------------------
    #  Print contents of message to stdout

    def print(self):
.for class.message
        if self.id == $(CLASS.NAME).$(MESSAGE.NAME):
            logger.info("$(MESSAGE.NAME):")
.   for field
.       if type = "number"
.           if defined (field.value)
            logger.info("    $(name)=$(field.value)")
.           else
            logger.info("    $(name)=%d" %$(name))
.           endif
.       elsif type = "octets"
            logger.info("    $(name)={0}".format($(name))
.       elsif type = "string" | type = "longstr"
.           if defined (field.value)
            logger.info("    $(name)=$(field.value)")
.           else
            if ($(name) != None):
                logger.info("    $(name)='%s'\\n" %$(name))
            else:
                logger.info("    $(name)=")
.           endif
.       elsif type = "strings"
            logger.info("    $(name)={0}".format($(name))
            #if ($(name) != null) {
            #    for (String value : $(name)) {
            #        System.out.printf (" '%s'", value);
            #    }
            #}
.       elsif type = "hash"
            logger.info("    $(name)={0}".format($(name))
.       elsif type = "frame" | type="msg" | type="uuid" | type="chunk"
            logger.info("    $(name)={0}".format($(name));
.       endif
.   endfor
        else:
            logger.info("(NULL)")

.endfor

    #  --------------------------------------------------------------------------
    #  Get/set the message routing id

    def routing_id(self):
        return self._routing_id

    def set_routing_id(self, routing_id):
        self._routing_id = routing_id

    #  --------------------------------------------------------------------------
    #  Get/set the $(class.name) id

    def id():
        return self._id

    def set_id(self, id):
        self._id = id

    #  --------------------------------------------------------------------------
    #  Return a printable command string
    def command(self):
.for class.message
        if self._id == $(CLASS.NAME)_$(MESSAGE.NAME):
            return ("$(MESSAGE.NAME)");
.endfor
        return "?";

.for class.field where !defined (value)
.   if type = "number" | type = "octets" | type = "string" | type = "longstr"
    #  --------------------------------------------------------------------------
    #  Get/set the $(name) field

    def $(name)(self):
        return _$(name);

    def set_$(name)(self, $(name)):
        self._$(name) = $(name)

.   elsif type = "strings" | type = "hash"
    #  --------------------------------------------------------------------------
    #  Get the $(name) field

    def $(name)(self):
        return self._$(name)

    def get_$(name)(self):
        return self._$(name)

    def set_$(name)(self, $(name)):
        self._$(name) = $(name)

.   elsif type = "uuid" | type = "chunk" | type = "frame" | type = "msg"
        #  --------------------------------------------------------------------------
    #  Get the $(name) field

    def $(name)(self):
        return self._$(name)

    def get_$(name)(self):
        return self._$(name)

    def set_$(name)(self, $(name)):
        self._$(name) = $(name)
.   endif
.endfor

.directory.create ("$(topdir)/test/python/$(name_path)")
.output "$(topdir)/test/python/$(name_path)/test_$(ClassName).py"

import unittest
import struct
import zmq

class $(ClassName)Test(unittest.TestCase):

    def test_create_destroy(self):
        #  Simple create/destroy test
        print(" * $(class.name): ");
        class1 = $(ClassName)()
        del(class1)
    
    def test_sockets(self)
        #  Create pair of sockets we can send through
        #  We must bind before connect if we wish to remain compatible with ZeroMQ < v4
        outsock = zmq.Socket(ctx, zmq.DEALER)
        outsock.bind("inproc://selftest-$(class.name)")

        insock = zmq.Socket(ctx, zmq.ROUTER)
        insock.bind("inproc://selftest-$(class.name)")

        #  Encode/send/decode and verify each message type
.for class.message

        msg = $(ClassName)($(ClassName).$(MESSAGE.NAME))
.   for field where !defined (value)
.       if type = "number"
        msg.set_$(name)(123)
.       elsif type = "octets"
        msg.set_$(name)(b'123')
.       elsif type = "string" | type = "longstr"
        msg.set_$(name) ("Life is short but Now lasts for ever")
.       elsif type = "strings"
        msg.set_$(name)(("Name: %s" %"Brutus"),("Age: %d" %43))
.       elsif type = "hash"
        msg._$(name).update("Name", "Brutus")
        msg._$(name).update("Age", "%d", 43);
.       elsif type = "chunk"
        msg.set_$(name)("Captcha Diem".decode('utf-8'))
.       elsif type = "frame"
        msg.set_$(name)(ZFrame("Captcha Diem"))
.       elsif type = "uuid"
        msg.set_$(name)(uuid.UUID(bytes=b'1'*16))
.       endif
.   endfor
        # Send twice
        msg.send(output);
        msg.send(output);
        

        msg = $(ClassName).recv(input)
.   for field where !defined (value)
.       if type = "number"
        self.assertEqual (self.$(name)(), 123)
.       elsif type = "octets"
        self.assertEqual(self.$(name) ), b'123')
.       elsif type = "string" | type = "longstr"
        self.assertEqual(self.$(name)(), "Life is short but Now lasts for ever")
.       elsif type = "strings"
        self.assertEqual(len(self.$(name)()), 2)
        self.assertEqual(self.$(name)()[0], "Name: Brutus")
        self.assertEqual(self.$(name)()[1], "Age: %d" %43)
.       elsif type = "hash"
        self.assertEqual(len(self.$(name)()), 2)
        self.assertEqual(self.$(name)()["Name"], "Brutus")
        self.assertEqual(self.$(name)()["Age"], 43)
.       elsif type = "chunk"
        self.assertEqual(self.$(name)(), "Captcha Diem".decode('utf-8'))
.       elsif type = "frame"
        self.assertEqual(msg.$(name)(), (ZFrame("Captcha Diem"))
.       elsif type = "uuid"
        self.assertEqual(msg.$(name)(), uuid.UUID(bytes=b'1'*16)
.       endif
.   endfor
        self.destroy ();
.endfor

        ctx.destroy ();
        print("OK")
    }
}
